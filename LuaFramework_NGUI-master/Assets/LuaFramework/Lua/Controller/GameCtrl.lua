---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2019/6/28 13:55
---

require "BasePlayerInfo"
require "StartGame"
require "MyHandCard"
require "BaseOtherHnad"
local json=require "cjson"

GameCtrl={}
local this=GameCtrl

local gameobject
local transform
local LuaBehaviour=nil
----Update事件
local UpdateHandle=nil

--保存玩家开始后的信息
this.Players={}
--游戏准备是自己的位置
this.PlayerPos=nil
--游戏开始后的峰位
this.MyFeng=nil
----保存websocket命令
this.Msg={}

--对象池名字 手牌
this.MyMaJiangPoolName="MyMaJiang"
this.TopMaJiangPoolName="TopMaJiang"
this.RightHandMaJiangPoolName="RightHandMaJiang"
this.LeftHandMaJiangPoolName="LeftHandMaJiang"
--对象池名字 吃碰
this.LeftChiPoolName="LeftChi"
this.MyPengPoolName="MyPeng"
this.TopPengPoolName="TopPeng"
this.RightChiPengPoolName="RightChiPeng"
--对象池名字,打出牌
this.DaChuPaiPoolName="MyChuPrefab"
this.RDaChuPaiPoolName="RightChuPrefab"
this.LDaChuPaiPoolName="LeftChuPrefab"
this.TDaChuPaiPoolName="TopChuPrefab"

--玩家头像位置
local PlayerInfoPos={
    ["M"]=Vector3.New(-50,0,0),
    ["R"]=Vector3.New(-80,0,0),
    ["L"]=Vector3.New(-10,-100,0),
    ["T"]=Vector3.New(-82,0,0),
}
--保存玩家palyerinfo类
this.PlayerInfos={
    ["M"]=nil,
    ["R"]=nil,
    ["L"]=nil,
    ["T"]=nil,
}
--玩家手牌初始位置   用于生成手牌
this.PlayerHandInitPos={
    ["M"]=Vector3.New(0,0,0),
    ["R"]=Vector3.New(210,-560,0),
    ["L"]=Vector3.New(0,0,0),
    ["T"]=Vector3.New(0,0,0),
}
---每个手牌,x,y差值
this.PlayerHandPosX={
    ["M"]=88,
    ["R"]=-15,
    ["L"]=-15,
    ["T"]=-56,
}
this.PlayerHandPosY={
    ["M"]=0,
    ["R"]=40,
    ["L"]=-40,
    ["T"]=0,
}

--this.DaChuPaiZu={
--    ["M"]=0,
--    ["R"]=40,
--    ["L"]=-40,
--    ["T"]=0,
--}

local pos={dong=0,nan=1,xi=2,bei=3}--便于计算
-----http协议
local GameReadyUrl="/game/ready"
----WebSocket发送的协议
local queryPanforme="{msg:queryPanforme}"

local DaoJishiHandle=nil
local DoJiShiTime=0
local DoJiShiTimelLabel=15

function GameCtrl.StartDaJiShi()
    --推荐使用这种Update方法
    GamePanel.CenterAnchor.gameObject:SetActive(true)
    DoJiShiTime=0
    DoJiShiTimelLabel=15
    DaoJishiHandle=UpdateBeat:CreateListener(this.DoJiShi,self)
    UpdateBeat:AddListener(DaoJishiHandle)
end
--移除按键检测
function GameCtrl.RemoveDaJiShi()
    GamePanel.CenterAnchor.gameObject:SetActive(false)
    UpdateBeat:RemoveListener(DaoJishiHandle)
end
----update的函数
function GameCtrl.DoJiShi()
    DoJiShiTime=DoJiShiTime+UnityEngine.Time.deltaTime
    if DoJiShiTime>=1 then
        DoJiShiTime=0
        DoJiShiTimelLabel=DoJiShiTimelLabel-1
        GamePanel.jishiq.text=tostring(DoJiShiTimelLabel)
    end
end
--------------------------------------------------------初始化--------------------------------------------------------
function GameCtrl.New()
    logWarn("GameCtrl.New--->>");
    return this;
end

function GameCtrl.Awake()
    panelMgr:CreatePanel('Game', this.OnCreate);
end

function GameCtrl.OnCreate(obj)
     currentGameType=GameProcess.Game
    gameobject=obj
    transform=obj.transform
    LuaBehaviour=transform:GetComponent("LuaBehaviour")
    ---顺序不能乱
    this.LoadAsset()
    --创建playerinfo;类
    this.CreatePlayerInfo()
    --创建手牌
    this.CreateHandAndSetPos()
    --开始间隔
    this.StartJianCe()
    --发送准备协议
    this.SendReadyToService()
    --创建按钮
    this.CreateReadyBtn()
    this.StartDaJiShi()
end

function GameCtrl.CreateReadyBtn()
    this.RerurnDaTingBtn=ButtonBase:New(GamePanel.fanhuidating)
    this.RerurnDaTingBtn:SetStart()
    this.RerurnDaTingBtn.okFunc=function()
        this.RemoveDaJiShi()
        gameWebSocket:CloseWeb()
        destroy(gameobject)
        CtrlManager.GetCtrl(CtrlNames.SignIn).Awake()
    end
end
---生成对象池
function GameCtrl.LoadAsset()
        this.MyMaJiang=LuaBehaviour:LoadAsset("MyMaJiang")
        this.TopMaJiang=LuaBehaviour:LoadAsset("TopMaJiang")
        this.RightHandMaJiang=LuaBehaviour:LoadAsset("RightHandMaJiang")
        this.LeftHandMaJiang=LuaBehaviour:LoadAsset("LeftHandMaJiang")
        this.LeftChi=LuaBehaviour:LoadAsset("LeftChi")
        this.MyPeng=LuaBehaviour:LoadAsset("MyPeng")
        this.TopPeng=LuaBehaviour:LoadAsset("TopPeng")
        this.RightChiPeng=LuaBehaviour:LoadAsset("RightChiPeng")
        this.MyChuPrefab=LuaBehaviour:LoadAsset("MyChuPrefab")

        this.RChuPrefab=LuaBehaviour:LoadAsset("RightChuPrefab")
        this.LChuPrefab=LuaBehaviour:LoadAsset("LeftChuPrefab")
        this.TChuPrefab=LuaBehaviour:LoadAsset("TopChuPrefab")
        --生成对象池 手牌14(si)个  吃碰是4(si)个
        objPoolMgr:CreatePool(this.MyMaJiangPoolName,14,14,this.MyMaJiang)
        objPoolMgr:CreatePool(this.TopMaJiangPoolName,14,14,this.TopMaJiang)
        objPoolMgr:CreatePool(this.RightHandMaJiangPoolName,14,14,this.RightHandMaJiang)
        objPoolMgr:CreatePool(this.LeftHandMaJiangPoolName,14,14,this.LeftHandMaJiang)
        objPoolMgr:CreatePool(this.LeftChiPoolName,4,4,this.LeftChi)
        objPoolMgr:CreatePool(this.MyPengPoolName,4,4,this.MyPeng)
        objPoolMgr:CreatePool(this.TopPengPoolName,4,4,this.TopPeng)
        objPoolMgr:CreatePool(this.RightChiPengPoolName,4,4,this.RightChiPeng)
        objPoolMgr:CreatePool(this.DaChuPaiPoolName,20,20,this.MyChuPrefab)
        objPoolMgr:CreatePool(this.RDaChuPaiPoolName,20,20,this.RChuPrefab)
        objPoolMgr:CreatePool(this.LDaChuPaiPoolName,20,20,this.LChuPrefab)
        objPoolMgr:CreatePool(this.TDaChuPaiPoolName,20,20,this.TChuPrefab)
end
------------------------保存服务器命令,然后挨个执行命令---------------------------------------------------------------------
function GameCtrl.SaveData(data)
    table.insert(this.Msg,data)
end
function GameCtrl.StartJianCe()
    --推荐使用这种Update方法
    UpdateHandle=UpdateBeat:CreateListener(this.JianCe,self)
    UpdateBeat:AddListener(UpdateHandle)
end
--移除按键检测
function GameCtrl.RemoveJianCe()
    UpdateBeat:RemoveListener(UpdateHandle)
end
----update的函数
function GameCtrl.JianCe()
    if #this.Msg>0 then
        this.HnadInfo( this.Msg[1])
        table.remove(this.Msg,1)
    end
end
-----------------------------------------------------------------http协议----------------------------------------------------------
--发送准备请求
function GameCtrl.SendReadyToService()
    local url=LocalGameHttpPort..GameReadyUrl.."?token="..GameInfo.GameToken
    log("房间准备"..url)
    Http_Helper.WebRequestText(url,this.SendReadyHnadle)
end
--准备请求回调
function GameCtrl.SendReadyHnadle(data)
    log(data.text)
    local jsondata=json.decode(data.text)
    if jsondata.success then
        log("准备成功")
    else
        log("准备失败"..jsondata.msg)
    end
end
-------------------------------------------------------websocket协议-------------------------------------------------------------
--处理消息
function GameCtrl.HnadInfo(data)
    --此方法必须有否则有的字符串判断会出错,不清楚具体原因,有可能是lua本身类型转换出问题
    local msg=tostring(data.msg)
    --房间信息
    if msg=="gameinfo" then
        this.HandPanForMeInfo(data.data)
    elseif msg=="joinGame" then
        this.HandJoinRoom(data.data)
    elseif msg=="start" then
        --查询panForme
        gameWebSocket:SendMsg(queryPanforme)
    elseif msg=="panforme" then
        currentGameType= GameProcess.GamePlaying
        this.RemoveDaJiShi()
        ----游戏开始后的逻辑都写在SatrtGame中
        StartGame.HnadPanForMe(data)
    elseif msg=="toAction" then--玩家可以执行的操作
        currentGameType= GameProcess.GamePlaying
        MyHandCard.HandToAction(data.data.toAction)
    elseif msg=="playerAction" then--非本人的操作
        StartGame.HandPlayerAction(data.data)
    elseif msg=="mopai" then--摸到的牌
        currentGameType= GameProcess.GamePlaying
        MyHandCard.MoPai("m"..data.data.mopai.pai)
    elseif msg=="toXiapao" then
        MyHandCard.CreateXiaPaoTable()
    end
end
--此处写错了
----处理gameinfo信息      测试 名字用playerId代替
 function  GameCtrl.HandPanForMeInfo(data)
     --显示个人信息
     for i , v in pairs(data.gameinfo.playerList) do
         this.PlayerPos=v.position
         this.PlayerInfos["M"]:SetInfo(v.headimgurl,v.playerId,0,0,PlayerInfoPos["M"])
     end
     for i , v in pairs(data.gameinfo.playerList) do
         this.SaveInfo(v.playerId,v.headimgurl,v.playerId)--todo 测试用playerId表示名字
         if v.state~="PlayerPlaying" then
             if v.playerId~=PlayerInfo.MemberId then
                 this.PlayerInfos[this.GetPosByPos(v.position)]:SetInfo(v.headimgurl,v.playerId,0,0,PlayerInfoPos[this.GetPosByPos(v.position)])
             end
         else
             this.PlayerInfos[this.Players[v.playerId].pos]:SetPaoFen(v.xiapao)
         end
     end
 end
----处理加入房间
function  GameCtrl.HandJoinRoom(data)
    this.PlayerInfos[this.GetPosByPos(data.joinGame.position)]:SetInfo(data.joinGame.headimgurl,data.joinGame.playerId,0,0,PlayerInfoPos[this.GetPosByPos(data.joinGame.position)])
    this.SaveInfo(data.joinGame.playerId,data.joinGame.headimgurl,data.joinGame.playerId)
end
--保存玩家信息信息
function GameCtrl.SaveInfo(playerId,headimgurl,name)
    if not this.Players[playerId] then
        this.Players[playerId]={}
    end
    this.Players[playerId].headimgurl=headimgurl
    this.Players[playerId].name=name
end
-------------------------------------------------------------------内置函数-----------------------------------------------------------------------------------
--预先生成手牌并摆放位置  这里会直接生成四个人的手牌
function GameCtrl.CreateHandAndSetPos()
    --生成个人手牌
    this.SetHandPos(this.PlayerHandInitPos["M"],this.PlayerHandPosX["M"],this.PlayerHandPosY["M"],this.MyMaJiangPoolName,GamePanel.MHand,true)
    --生成上方手牌
    this.SetHandPos(this.PlayerHandInitPos["T"],this.PlayerHandPosX["T"],this.PlayerHandPosY["T"],this.TopMaJiangPoolName,GamePanel.THand,true)
    --生成左侧手牌
    this.SetHandPos(this.PlayerHandInitPos["L"],this.PlayerHandPosX["L"],this.PlayerHandPosY["L"],this.LeftHandMaJiangPoolName,GamePanel.LHand,true)
    --生成右侧手牌
    this.SetHandPos(this.PlayerHandInitPos["R"],this.PlayerHandPosX["R"],this.PlayerHandPosY["R"],this.RightHandMaJiangPoolName,GamePanel.RHand,false)
end

--根据坐标生成手牌
function GameCtrl.SetHandPos(initPos,xDistance,yDistance,poolName,parent,isDepth)
    for i = 1, 14 do
        local obj= objPoolMgr:Get(poolName)
        obj.gameObject:SetActive(true)
        if isDepth then
            obj:GetComponent("UISprite").depth=i
        else
            obj:GetComponent("UISprite").depth=15-i--左侧手牌比较特殊,越往上深度越低  注意:深度值要从1开始,否则0的深度会被遮挡
        end
        obj.transform:SetParent(parent)
        --第十四张牌为摸牌,间隔要远些,并且需要隐藏
        if i==14 then
            obj.gameObject:SetActive(false)
            obj.transform.localPosition=Vector3.New(initPos.x+i*xDistance,initPos.y+i*yDistance,initPos.z)
        else
            obj.transform.localPosition=Vector3.New(initPos.x+(i-1)*xDistance,initPos.y+(i-1)*yDistance,initPos.z)
        end
    end
end
---通过自己位置得到他人的位置
function GameCtrl.GetPosByPos(ReadyPos)
    local temp=pos[ ReadyPos]
    local Mypos=pos[this.PlayerPos]
    if Mypos-temp==2 or Mypos-temp==-2 then      --确定对家位置
        return  "T"
    elseif Mypos-temp==-1 or Mypos-temp==3 then --确定右侧位置
        return "R"
    else
        return  "L"   --确定左侧位置
    end
end
----确定玩家位置,并将信息保存在this.Players表中,这里相当于字典 key值为id,value为table,  有很多种实现方式
function GameCtrl.DeterminePos(PlayList)
    --个人信息ID
    local MyId=PlayerInfo.MemberId
    --生成字典
    for i=1,#PlayList,1 do
        if not this.Players[ PlayList[i].id] then
            this.Players[ PlayList[i].id]={}
        end
        if PlayList[i].id==MyId then
            this.MyFeng=PlayList[i].menFeng
        end
    end
    --两个人,对家在上方
    if #PlayList==2 then
        for i=1,#PlayList,1 do
            if PlayList[i].id~=MyId then
                this.Players[ PlayList[i].id].pos="T"
            else
                this.Players[ PlayList[i].id].pos="M"
            end
        end
    else--三个人或四个人
        local Mypos--我自己的位置 dong=0,nan=1,xi=2,bei=3
        --确定我自己的位置
        for i=1,#PlayList,1 do
            if PlayList[i].id==MyId then
                this.Players[ PlayList[i].id].pos="M"
                --得到值如:  东==0
                Mypos=pos[ PlayList[i].menFeng]
                break
            end
        end
        --确定其他玩家位置 与对家相减等于2或-2 ,右侧相减等于-1或3 ,左侧侧相减等于 1或-3
        for i=1,#PlayList,1 do
            if PlayList[i].id~=MyId then
                local temp=pos[ PlayList[i].menFeng]
                if Mypos-temp==2 or Mypos-temp==-2 then      --确定对家位置
                    this.Players[ PlayList[i].id].pos="T"
                elseif Mypos-temp==-1 or Mypos-temp==3 then --确定右侧位置
                    this.Players[ PlayList[i].id].pos="R"
                else
                    this.Players[ PlayList[i].id].pos="L"   --确定左侧位置
                end
            end
        end
    end
end
--游戏开始头像赋值,
function GameCtrl.SetHeadInfoByStartGame(isPlayAni)
    for i,v in pairs(this.Players) do
        this.PlayerInfos[v.pos]:SetInfo(v.headimgurl,v.name,0,0,PlayerInfoPos[v.pos])
        --if isPlayAni then
        --    this.PlayerInfos[v.pos]:PlayForward()
        --end
    end
end
----创建playerInfo类
function GameCtrl.CreatePlayerInfo()
    this.PlayerInfos["M"]=BasePlayerInfo:New(GamePanel.MInfo)
    this.PlayerInfos["T"]=BasePlayerInfo:New(GamePanel.TInfo)
    this.PlayerInfos["L"]=BasePlayerInfo:New(GamePanel.LInfo)
    this.PlayerInfos["R"]=BasePlayerInfo:New(GamePanel.RInfo)
end
----------设置按钮
----todo 创建表
--function GameCtrl.CreateTable()
--    this.ReturnBtn=ButtonBase:New(GamePanel.Return)
--    this.MoreSettingBtn=ButtonBase:New(GamePanel.MoreSetting)
--    this.SetTable()
--    this.SetOkFunc()
--end
----设置表的关系
--function GameCtrl.SetTable()
--    this.ReturnBtn:SetAllTable(nil,this.GameExpressioAndWittyBtn,this.MoreSettingBtn,nil)
--
--    this.MoreSettingBtn:SetAllTable(nil,nil,nil,this.GameExpressioAndWittyBtn)
--
--    this.GameExpressioAndWittyBtn:SetAllTable(this.ReturnBtn,nil,this.MoreSettingBtn,nil)
--end
----设置确定函数
--function GameCtrl.SetOkFunc()
--    this.ReturnBtn.okFunc=function()
--        this.ReturnBtn=nil
--        this.MoreSettingBtn=nil
--        this.GameExpressioAndWittyBtn=nil
--        this.Close()
--        gameobject=nil
--        transform=nil
--        --todo 显示大厅
--    end
--    this.MoreSettingBtn.okFunc=function()
--        CtrlManager.GetCtrl(CtrlNames.GameMoreSetting).Awake()
--    end
--end
--
function GameCtrl.SetSettingBtn()
    MyHandCard.Setting:SetStart()
end

function GameCtrl.SetTuiChuBtn()
    MyHandCard.tuichu:SetStart()
end

function GameCtrl.UpdateShengYuCount()
    --StartGame.UpdateShengYuCount()
end

function GameCtrl.Close()
    panelMgr:ClosePanel(CloseNames.Game);
end

